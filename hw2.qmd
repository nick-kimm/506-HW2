---
title: "hw2"
author: "Nick Kim"
format:
  html:
    embed-resources: true
---

Link to my GitHub: <https://github.com/nick-kimm/506-HW2>.

## Problem 1: Dice Game

Letâ€™s play a dice game. It costs $2 to play. You roll a single 6-sided die.

-On a roll of 3 or 5, you win twice your roll.
-On any other roll, you lose.

The input and output should be:

Input: The number of dice to roll.
Output: Total winnings

#Part a:
#Version 1: Loop
```{r}
#' Version 1 Dice Game
#'Will implement the Dice Game using a for loop. Will check each index in the simulated rolls and will check if that number if either a 3 or a 5. If it is then it'll increase the total winnings by 4 as that is the net profit from that roll. If it neither then it'll subtract 2 from the winnings as that is the cost of this situation. 
#'
#' @param x (number of rolls)
#'
#' @return Total Winnings a/f x number of rolls
play_dice <- function(x){
  rolls <- sample(1:6,x,replace=TRUE)
  winnings <- 0
  for (i in 1:x){
    if (rolls[i]==3 | rolls[i]==5){
      winnings <- winnings + 4
    }
    else{
      winnings <- winnings - 2
    }
  }
  return(winnings)
}
```

#Version 2: Vectorized functions in R
```{r}
#' Version 2 Dice Game
#'Samples the random roll for x number of rolls. Next will calculate the winnings by checking if the roll isn't a 3 or a 5 and then multiplying it by -2 as you'll lose that much in this game. Then it'll add it to the rolls that are 3 or a 5 by 4 as you would double the amount you put in ($2). Finally sum over this whole vector to get your total winnings after x rolls
#' @param x 
#'
#' @return Total winnings 
#'
#' @examples rolls <- 2 5 2 6 4 2 1 3 5 6
#' winnings <- sum(-2 0 -2 -2 -2 -2 -2 0 0 -2 (1st conditionals) + 0 4 0 0 0 0 0 4 4 0 (2nd conditional))
#' winnings <- sum(-2 4 -2 -2 -2 -2 -2 4 4 -2)
#' winnings <- -2 
play_dice2 <- function(x){
  rolls <- sample(1:6,x,replace=TRUE)
  winnings <- sum((rolls!=3 & rolls!=5)*-2+(rolls==3 | rolls==5)*4)
  return(winnings)
}
```

#Version 3: Table approach
```{r}
#' Version 3 Dice Game
#'It'll first convert the rolls to a table with the values 1 to 6 in the first row followed by the count of each of these rolls in the 2nd row. Then the total winnings is calculated by rolls of 3 or 5 multiplied by 4 subtracted by other rolls multiplied by 2. 
#' @param x 
#'
#' @return Total winnings 
#'
#' @examples rolls <- 4 5 6 1 3 
#' 
#' roll_t <- 1 2 3 4 5 6
#'           1 0 1 1 1 1
#'
#'output <- (0+1)*4- (1+1+1+1)*2
#'.      <- -4
play_dice3 <- function(x){
  rolls <- sample(1:6,x,replace=TRUE)
  roll_t<-table(factor(rolls, levels = 1:6))
  return((roll_t[["3"]]+roll_t[["5"]])*4-(roll_t[["1"]]+roll_t[["2"]]+roll_t[["4"]]+roll_t[["6"]])*2)
}
```

#Version 4: Apply function
```{r}
#' Version 4 Dice Game
#'Will create a matrix that will replace any value of a 3 or a 5 to be 4 and anything else to -2 as that would be how much you would profit or loose in playing this game. Then we'll use the apply function to sum over all these values down the column to get our total winnings.
#' @param x 
#'
#' @return Total winnings
#'
#' @examples rolls <- 6 4 6 3 
#' profit <- [-2 -2 -2 4]^T
#' output <- -2
play_dice4 <- function(x){
  rolls <- sample(1:6,x,replace=TRUE)
  profit <- matrix(ifelse((rolls==3|rolls==5),4,-2))
  return(apply(profit,2,sum))
}
```

#Part b: 

```{r}
#Version 1 test:
c(play_dice(3),play_dice(3000))

#Version 2 test:
c(play_dice2(3),play_dice2(3000))

#Version 3 test:
c(play_dice3(3),play_dice3(3000))

#Version 4 test:
c(play_dice4(3),play_dice4(3000))
```
#Part c:
First need to edit the functions above to account for a set seed
```{r}
seed=0

play_dice_seed <- function(x,seed){
  set.seed(seed)
  rolls <- sample(1:6,x,replace=TRUE)
  winnings <- 0
  for (i in 1:x){
    if (rolls[i]==3 | rolls[i]==5){
      winnings <- winnings + 4
    }
    else{
      winnings <- winnings - 2
    }
  }
  return(winnings)
}

play_dice2_seed <- function(x,seed){
  set.seed(seed)
  rolls <- sample(1:6,x,replace=TRUE)
  winnings <- sum((rolls!=3 & rolls!=5)*-2+(rolls==3 | rolls==5)*4)
  return(winnings)
}

play_dice3_seed <- function(x,seed){
  set.seed(seed)
  rolls <- sample(1:6,x,replace=TRUE)
  roll_t<-table(factor(rolls, levels = 1:6))
  return((roll_t[["3"]]+roll_t[["5"]])*4-(roll_t[["1"]]+roll_t[["2"]]+roll_t[["4"]]+roll_t[["6"]])*2)
}

play_dice4_seed <- function(x,seed){
  set.seed(seed)
  rolls <- sample(1:6,x,replace=TRUE)
  profit <- matrix(ifelse((rolls==3|rolls==5),4,-2))
  return(apply(profit,2,sum))
}
```

Next testing if it'll get the same values
```{r}
seed = 100

print("v1")
c(play_dice_seed(3,seed),play_dice_seed(3000,seed))
print("v2")
c(play_dice2_seed(3,seed),play_dice2_seed(3000,seed))
print("v3")
c(play_dice3_seed(3,seed),play_dice3_seed(3000,seed))
print("v4")
c(play_dice4_seed(3,seed),play_dice4_seed(3000,seed))
```
#Part d:

Low input: x = 1000
```{r}
library(microbenchmark)

x <- 1000
seed <- 100

microbenchmark(
  v1 <- play_dice_seed(x,seed),
  v2 <- play_dice2_seed(x,seed),
  v3 <- play_dice3_seed(x,seed),
  v4 <- play_dice4_seed(x,seed)
)
```

From the resulting table above in the case x is a low input (1,000). The fastest performing function was v2 or the function using the vectorized functions in R. The next fastest was v4 followed by v3 and lastly v1. From our discussion in class it is no surprise v1 is the slowest as it is reassigning the object winnings for every integer in the vector rolls. The apply function is not too far behind from the vectorized solution and it's surprising to see the table solution is almost as slow as the looping solution case. 


Large input: x = 100,000

```{r}
x <- 100000
seed <- 100

microbenchmark(
  v1 <- play_dice_seed(x,seed),
  v2 <- play_dice2_seed(x,seed),
  v3 <- play_dice3_seed(x,seed),
  v4 <- play_dice4_seed(x,seed)
)
```

From the table above we can see that by far and away v2 or the vectorized functions are our best route in terms of speed. The other options in the table solutions (v3) and the apply function (v4) are almost just as fast in terms of efficiency while the looping solution is by far the slowest solution. From this we can conclude we should try and use vectorized functions in R if possible, especially if speed is of concern. 

#Part e: 

```{r}
nsim <- 10000
x <- sample(1:1000,1)
  
profit <- vector(length=nsim)

for (i in 1:nsim){
  profit[i] <- play_dice2(x)
}

mean(profit)
```

I think it is a fair game as the average profit of the game should be 50/50 or equal to zero. After running the game 10,000 times in a Monte Carlo simulation we can see that the mean is zero.  

##Question 2

#Part a: 
```{r}
cars <- read.csv("/Users/nicholaskim/Documents/STAT 506/HW2/cars.csv")

names(cars) <- c("Height","Length","Width","Dive_type","Engine_type","Is_hybrid","Num_fwd_gears","Trans_type","City_mpg","Fuel_type","Highway_mpg","Manual_or_auto","Car_id","Car_make","Make_n_yr","Model_yr","Horsepower","Torque")
```

#Part b:
```{r}
cars_r <- cars[cars[,10]=="Gasoline",]
```

#Part c:
```{r}
hist(cars_r$Highway_mpg,freq=TRUE)
hist(cars_r$Highway_mpg[cars_r$Highway_mpg<100],breaks=10,freq=TRUE)
```
From the plot of Highway MPG we can see that there is one outlier point but when looking at the rest of the distribution it looks to fall between a nice range of values and follow somewhat of a normal distribution. For this reason I feel we don't need a transformation of this column. 

#Part d: 
```{r}
Model_yr = as.factor(cars_r$Model_yr)
model <- lm(Highway_mpg~Height+Length+Width+Model_yr+Horsepower+Torque,data=cars_r)
summary(model)
```

From the summary output we can see that Torque and Highway MPG are statistically significant. Specifically, the estimated coefficient for Torque is -5.102e-02. This means that while keeping all other variables constant then two individuals who differ in Torque by 1 unit are expected to be 5.102e-02 smaller. 

#Part e:
```{r}
model2 <- lm(Highway_mpg~Torque*Horsepower+Height+Length+Width+Model_yr,data=cars_r)

summary(model2)
```


```{r}
plot(cars_r$Torque,cars_r$Highway_mpg,col="red",ylim=c(0,50))
points(cars_r$Horsepower,cars_r$Highway_mpg,col="green",ylim=c(0,50))
```

#Part f:
```{r}
design_mat <- data.frame(cars_r[,1:3],cars_r[,16:18])
#adding the intercept column in first column to this reduced dataset
#made it a matrix to then do matrix multiplication with 
design_mat <- as.matrix(cbind(Intercept = rep(1,nrow(cars_r)), design_mat)) 

ymat <- cars_r$Highway_mpg

beta_hat <- solve(t(design_mat)%*%design_mat)%*%t(design_mat)%*%ymat

data.frame(manual_beta_est = beta_hat, 
           lm_beta_est = model$coefficients)
```
From the outputs above we can see that the beta estimates from our manual solution is the same as the coefficients from our lm() model. For example, the intercepts are both -1.605e+03 and Heights are 9.821e-03 in both our models. 




